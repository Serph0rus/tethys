mapping scheme
bootstrap gdt
bootstrap system allocator
acpi parsing
lapic counting
find highest memory address
find first satisfactory region
free page bitmap
parse memory map
mark bitmap as allocated
page frame allocator
qemu exit codes
fix pfa bitmap
split system stacks into interrupt stacks, per-process system stacks, and a bootstrap stack
gdt structures for dynamic allocation
custom bootstrap gdt
paging structures & functions
process control block
track page mappings for each process
track ownership of and page frame ownership for messages
track ownership of processes by parent processes
create filesystem servers
track ownership of filesystem servers & messages
solidify syscall interface
system stacks
implement userspace-kernelspace separation for preemption in proc.rs
managed page tables for processes
// complete ^^
// to do \/ \/
thread-local storage
switch into process
syscall testing
catch out of process
basic round-robin scheduler
syscall stack deallocation
check proc.rs for race conditions
solidify tethys filesystem interface
rewrite ABI.md
kickstart process elf loader
boilerplate kickstart process
traversal of filesystems in a tree by string
create system-owned filesystem interface
system-owned x86_64 port i/o filesystem
userspace debugcon server
ring 0 userspace hello world program
system-owned process server
single core round-robin scheduler
release control from boot process to scheduler
userspace elf loader
system-owned irq filesystem
atapio driver
fat32 driver
ps2 keyboard server
ps2 mouse server
framebuffer server
console server
shell
framebuffer + mouse + keyboard multiplexer
split kernel allocator into multicore-safe allocators
move to fixed-priority multicore-safe scheduler
real gdt
ap trampoline
initialise all other processors to scheduler
switch to ring-3 unprivileged user processes
calculate priorities of processes based on heirarchy
implement lazy allocation for mapped pages
implement copy-on-write for sent pages
floating-point context switching
pcid cache